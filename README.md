‚å®Ô∏è Algorithms with Swift.
=====

### Key Algorithms & Data Structures / –û—Å–Ω–æ–≤–Ω—ã–µ –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ –°—Ç—Ä—É–∫—Ç—É—Ä—ã –î–∞–Ω–Ω—ã—Ö

### 1. –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

- Linked Lists (–°–≤—è–∑–Ω—ã–µ —Å–ø–∏—Å–∫–∏)
     - –ü—Ä–∏–º–µ—Ä—ã: –æ–¥–Ω–æ—Å–≤—è–∑–Ω—ã–µ –∏ –¥–≤—É—Å–≤—è–∑–Ω—ã–µ —Å–ø–∏—Å–∫–∏. –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç—å—é, –ø–æ–∑–≤–æ–ª—è—é—â–µ–µ –≥–∏–±–∫–æ –≤—Å—Ç–∞–≤–ª—è—Ç—å –∏ —É–¥–∞–ª—è—Ç—å —É–∑–ª—ã –≤ –ª–∏–Ω–µ–π–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
     - Examples: singly linked and doubly linked lists. Efficient dynamic memory management, allowing flexible node insertion and deletion in a linear sequence.

- Hash Table (–•–µ—à-—Ç–∞–±–ª–∏—Ü–∞)
     - –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—â–∞—è –±—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø, –≤—Å—Ç–∞–≤–∫—É –∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏–π.
     - A data structure providing constant-time complexity for lookups, insertions, and deletions via hash functions.

- Heap (–ö—É—á–∞)
     - –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–º–∏ –æ—á–µ—Ä–µ–¥—è–º–∏ –∏ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á, —Ç–∞–∫–∏—Ö –∫–∞–∫ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ k –Ω–∞–∏–±–æ–ª—å—à–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
     - A data structure used for efficient priority queue management and finding the k-largest or k-smallest elements.

- Tree (–î–µ—Ä–µ–≤–æ)
     - –ò–∑—É—á–µ–Ω–∏–µ –±–∏–Ω–∞—Ä–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤, –¥–µ—Ä–µ–≤—å–µ–≤ –ø–æ–∏—Å–∫–∞ –∏ –¥–µ—Ä–µ–≤—å–µ–≤ AVL –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö.
     - Study binary trees, AVL trees, and binary search trees (BSTs) for data organization and traversal.

- Stack (–°—Ç–µ–∫)
     - –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∑–∞–¥–∞—á —Ç–∏–ø–∞ "–ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–∏—à–µ–ª, –ø–µ—Ä–≤—ã–π —É—à–µ–ª".
     - Core data structure used for Last-In-First-Out (LIFO) tasks.

- Queue (–û—á–µ—Ä–µ–¥—å)
     - –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏.
     - Core data structure used in sequential processing.

### 2. –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø–æ–∏—Å–∫–∞ –∏ –æ–±—Ö–æ–¥–∞

- DFS/BFS (Depth-First Search / Breadth-First Search) (–ü–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É / –ü–æ–∏—Å–∫ –≤ —à–∏—Ä–∏–Ω—É)
     - –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ—Ö–Ω–∏–∫–∏ –æ–±—Ö–æ–¥–∞ –≥—Ä–∞—Ñ–æ–≤ –∏ –¥–µ—Ä–µ–≤—å–µ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø—É—Ç–µ–π.
     - Fundamental graph and tree traversal techniques used for searching and pathfinding.

- Binary Search (–ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫)
     - –ë—ã—Å—Ç—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–∏—Å–∫–∞ –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏—è—Ö —Å –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é.
     - A fast and efficient algorithm to search within sorted collections with logarithmic time complexity.

### 3. –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

- Sorting Algorithms (–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏)
     - –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏, —Ç–∞–∫–∏–µ –∫–∞–∫ QuickSort –∏ MergeSort, —Å —Ñ–æ–∫—É—Å–æ–º –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å.
     - Explore various sorting techniques such as QuickSort and MergeSort, focusing on time and space complexity.

### 4. –ê–ª–≥–æ—Ä–∏—Ç–º—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

- Dynamic Programming (–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ)
     - –ü—Ä–∏–Ω—Ü–∏–ø—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–¥–∞—á —Å –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—â–∏–º–∏—Å—è –ø–æ–¥–∑–∞–¥–∞—á–∞–º–∏.
     - Principles of optimizing problems with overlapping subproblems.

- Greedy Algorithms (–ñ–∞–¥–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã)
     - –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –≥–¥–µ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.
     - Solve optimization problems by making locally optimal choices at each step to potentially find global solutions.

- Divide and Conquer (–†–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π)
     - –ü—Ä–∏–º–µ—Ä: QuickSort, MergeSort. –ü—Ä–∏–Ω—Ü–∏–ø –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ –Ω–∞ –ø–æ–¥–∑–∞–¥–∞—á–∏ –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è —Ä–µ—à–µ–Ω–∏—è.
     - Example: QuickSort, MergeSort. The principle involves breaking a problem into smaller subproblems for simpler solutions.

### 5. –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –≥—Ä–∞—Ñ–∞—Ö

- Graph Algorithms (–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Ä–∞–±–æ—Ç—ã —Å –≥—Ä–∞—Ñ–∞–º–∏)
     - –ü—Ä–∏–º–µ—Ä: –ê–ª–≥–æ—Ä–∏—Ç–º—ã –î–µ–π–∫—Å—Ç—Ä—ã, –ö—Ä–∞—Å–∫–∞–ª–∞, –ü—Ä–∏–º–∞. –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –∫—Ä–∞—Ç—á–∞–π—à–∏–º–∏ –ø—É—Ç—è–º–∏, –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –æ—Å—Ç–æ–≤–Ω—ã–º –¥–µ—Ä–µ–≤–æ–º –∏ —Ü–∏–∫–ª–∏—á–Ω–æ—Å—Ç—å—é –≥—Ä–∞—Ñ–æ–≤.
     - Example: Dijkstra's, Kruskal's, Prim's algorithms. Solve problems like shortest path, minimum spanning tree, and graph cycles.

- Union-Find (–ê–ª–≥–æ—Ä–∏—Ç–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è)
     - –ü—Ä–∏–º–µ—Ä: —Ä–∞–±–æ—Ç–∞ —Å –Ω–µ–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–º–∏—Å—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏ –≤ –≥—Ä–∞—Ñ–∞—Ö. –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ –≥—Ä–∞—Ñ–æ–≤.
     - Example: disjoint-set data structure for handling graph components efficiently.

### 6. –¢–µ—Ö–Ω–∏–∫–∏ –¥–ª—è –∑–∞–¥–∞—á –Ω–∞ –º–∞—Å—Å–∏–≤—ã –∏ —Å—Ç—Ä–æ–∫–∏

- Two Pointers (–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è)
     - –ü–æ–ª–µ–∑–Ω–∞—è —Ç–µ—Ö–Ω–∏–∫–∞ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á —Å –º–∞—Å—Å–∏–≤–∞–º–∏ –∏ —Å—Ç—Ä–æ–∫–∞–º–∏, —Ç–∞–∫–∏—Ö –∫–∞–∫ –∑–∞–¥–∞—á–∞ –æ –¥–≤—É—Ö —Å—É–º–º–∞—Ö.
     - A useful technique for solving problems involving arrays and strings, like finding pairs that meet specific conditions.

- Sliding Window (–°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ)
     - –ê–ª–≥–æ—Ä–∏—Ç–º —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á —Å –ø–æ–¥–º–∞—Å—Å–∏–≤–∞–º–∏ –∏–ª–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞–º–∏.
     - A dynamic range algorithm used for solving problems related to subarrays or substrings efficiently.
-----

Big O Notation
-----

- Big O Notation - —ç—Ç–æ —Å–ø–æ—Å–æ–± –æ—Ü–µ–Ω–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–ø–µ—Ä–∞—Ü–∏–π, –≤—ã–ø–æ–ª–Ω—è–µ–º—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–º, –æ—Ç —á–∏—Å–ª–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–∞–Ω–Ω—ã—Ö.
     - O(n) –æ–±–æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π –ª–∏–Ω–µ–π–Ω–æ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–∞–Ω–Ω—ã—Ö.
     - O - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞.
     - n ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º.
 
- Big O Notation is a way to measure how the number of operations performed by the processor depends on the number of data elements.
     - O(n) means that the number of operations grows linearly with the number of data elements.
     - O represents the total number of operations required to complete the algorithm.
     - n is the number of elements the algorithm processes.
 
`````swift
import UIKit

// O(1) - –ï–¥–∏–Ω–∏—á–Ω–∞—è (–∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è) —Å–ª–æ–∂–Ω–æ—Å—Ç—å
func getValueFor(index: Int, in array: [Int]) -> Int? {
    guard index < array.count else { return nil }
    
    return array[index]
}

getValueFor(index: 2, in: [1,2,3,4,5])

// O(n) - –õ–∏–Ω–µ–π–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å
func sum(array: [Int]) -> Int {
    var sum = 0
    array.forEach { sum += $0 }
    return sum
}

// O(2*n)
func sum(array: [Int]) -> (Int, Int) {
    var sum = 0
    var mult = 1
    array.forEach { sum += $0 }
    
    array.forEach { num in
        mult *= num
    }
    
    return (sum, mult)
}

// O(n)
func multiTab(array: [Int]) {
    for num1 in array {
        for num2 in array {
            print("\(num1) * \(num2) = \(num1 * num2)")
        }
    }
}
`````

-----

- Tree (–î–µ—Ä–µ–≤–æ)

`````swift

import UIKit

// Node (–£–∑–µ–ª)
class TreeNode<T> {
    var value: T
    var children: [TreeNode] = []
    
    init(value: T) {
        self.value = value
    }
    
    func add(_ child: TreeNode) {
        children.append(child)
    }
}

extension TreeNode {
    func forEach(visit: (TreeNode) -> ()) {
        visit(self)
        children.forEach { $0.forEach(visit: visit) }
    }
}

struct Product {
    let title: String
    let category: String
    let subCategory: String
}

let productsTree = TreeNode(value: "Catalog")
let shoesTree = TreeNode(value: "Shoes")
let womenShoes = TreeNode(value: "Women Shoes")
let menShoes = TreeNode(value: "Men Shoes")
let sneakers = TreeNode(value: "Sneakers")
let oxfords = TreeNode(value: "Oxfords")
let slippers = TreeNode(value: "Slippers")
let crocs = TreeNode(value: "Crocs")

productsTree.add(shoesTree)
shoesTree.add(womenShoes)
shoesTree.add(menShoes)
womenShoes.add(slippers)
womenShoes.add(crocs)
menShoes.add(sneakers)
menShoes.add(oxfords)

productsTree.forEach { node in
    print(node.value)
}
`````

- Queue (–û—á–µ—Ä–µ–¥—å)

`````swift
import UIKit

// Queue / Simple data structure - —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É FIFO

struct Queue<T> {
    private var container: [T] = []
    
    var size: Int { container.count }
    var isEmpty: Bool { container.isEmpty }
    
    var head: T? { container.first }
    var tail: T? { container.last }
    
    // mutating - add into struct
    mutating func enqueue(_ t: T) {
        container.append(t)
    }
    
    @discardableResult // a modifier that allows ignoring a function's return value.
    mutating func dequeue() -> T? {
        guard !isEmpty else { return nil }
        return container.removeFirst()
    }
}

extension Queue {
    init(_ array: [T]) {
        self.container = array
    }
    
    mutating func enqueue(_ array: [T]) {
        self.container += array
    }
    
    mutating func dequeue(number: Int) -> [T] {
        guard number < container.count else {
            let array = container
            container.removeAll()
            return array
        }
        
        var array = [T]()
        for _ in 0..<number {
            array.append(container.removeFirst())
        }
        return array
    }
}

// Test
var queue = Queue<String>()
queue.enqueue("Eli")
queue.enqueue("Elijah")
queue.size
queue.isEmpty
queue.head
queue.tail
queue.enqueue(["ü´†", "ü•π", "üòá", "üòá"])
queue.size
queue.head
queue.tail

let array = queue.dequeue(number: 4)
print(array)
queue.size
queue.head
queue.tail

var queue1 = Queue(["Kim", "Mom", "Aunt"])
queue1.size

`````

- Deque (–î–≤–æ–π–Ω–∞—è –æ—á–µ—Ä–µ–¥—å)

`````swift
import UIKit

// Deque / Simple data structure - C–Ω–∞—á–∞–ª–∞ –∫—Ä–∞–π–Ω–∏–µ –∏ –ø–æ—Å–ª–µ —Å—Ä–µ–¥–Ω—è—è

struct Deque<T> {
    private var container: [T] = []
    
    var size: Int { container.count }
    var isEmpty: Bool { container.isEmpty }
    
    var head: T? { container.first }
    var tail: T? { container.last }
    
    // mutating - add into struct
    mutating func addLast(_ t: T) {
        container.append(t)
    }
    
    mutating func addFirst(_ t: T) {
        container.insert(t, at: 0)
    }
    
    @discardableResult // a modifier that allows ignoring a function's return value.
    mutating func removeFirst() -> T? {
        guard !isEmpty else { return nil }
        return container.removeFirst()
    }
    
    @discardableResult // a modifier that allows ignoring a function's return value.
    mutating func removeLast() -> T? {
        guard !isEmpty else { return nil }
        return container.removeLast()
    }
}

var deque = Deque<String>()
deque.addFirst("Mac")
deque.addLast("Macbook")
deque.addFirst("iMac")
deque.addLast("iPad")

deque.removeLast()
deque.removeLast()
deque.removeLast()
deque.removeLast()
`````

- Linked Lists (–°–≤—è–∑–Ω—ã–µ —Å–ø–∏—Å–∫–∏)

`````swift
import UIKit

// Node / –£–∑–µ–ª —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
class Node<T> {
    var value: T
    weak var next: Node?
    weak var previous: Node?
    
    init(_ value: T) {
        self.value = value
    }
}

class LinkedList<T> {
    private var head: Node<T>?
    private var tail: Node<T>?
    
    var isEmpty: Bool { head == nil }
    var first: T? { head?.value }
    var last: T? { tail?.value }
}

extension LinkedList {
    // Add to end of list / –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞
    func append(_ value: T) {
        let newNode = Node(value) // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —É–∑–µ–ª
        
        if let tail { // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –Ω–µ –ø—É—Å—Ç–æ–π
            newNode.previous = tail
            tail.next = newNode
        } else { // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç–æ–π
            head = newNode
        }
        // –¢–µ–ø–µ—Ä—å —Ö–≤–æ—Å—Ç –Ω–æ–≤—ã–π —É–∑–µ–ª
        tail = newNode
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —É–∑–ª–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É (–ø–æ –ø–æ—Ä—è–¥–∫–æ–≤–æ–º—É –Ω–æ–º–µ—Ä—É)
    private func nodeBy(_ index: Int) -> Node<T>? {
        guard index >= 0 else { return nil }
        var currentNode = head
        var i = index
        
        while currentNode != nil {
            if i == 0 { return currentNode }
            i -= 1
            currentNode = currentNode?.next
        }
        return nil
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ –∏–Ω–¥–µ–∫—Å—É
    func value(at index: Int) -> T? {
        let node = nodeBy(index)
        return node?.value
    }
    
    // –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É / [1 <-> 8 <-> 3 <-> 5 <-> 4]
    @discardableResult // a modifier that allows ignoring a function's return value.
    func remove(at index: Int) -> T? {
        guard let removedNode = nodeBy(index) else { return nil }
        let previous = removedNode.previous
        let next = removedNode.next
        
        if let previous {
            previous.next = next
        } else {
            head = next
        }
        
        if let next {
            next.previous = previous
        } else {
            tail = previous
        }
        
        removedNode.next = nil
        removedNode.previous = nil
        
        return removedNode.value
    }
}

// [1 <-> 8 <-> 3 <-> 5 <-> 4]
extension LinkedList: CustomStringConvertible {
    var description: String {
        var text = "["
        var currentNode = head
        while currentNode != nil {
            text += "\(currentNode!.value)"
            currentNode = currentNode?.next
            if currentNode != nil { text += " <-> " }
        }
        text += "]"
        return text
    }
}

// Test
var fishes = LinkedList<String>()
fishes.first
fishes.last
fishes.isEmpty
print(fishes)
fishes.append("trout")
print(fishes)
fishes.append("salmon")
fishes.append("tuna")
fishes.append("sea bass")
fishes.append("cod")
print(fishes)
fishes.last

fishes.value(at: 3)
fishes.remove(at: 1)
print(fishes)
`````

- Stack (–°—Ç–µ–∫)

`````swift
import UIKit

struct Stack<T> {
    private var container: [T] = [] // Private container
    var size: Int { container.count } // Size
    var isEmpty: Bool { container.isEmpty } // Empty
    var top: T? { container.last } // Top Element
    
    mutating func push(_ value : T) {
        self.container.append(value)
    }
    
    mutating func pop() -> T? {
        guard !self.isEmpty else {
            return nil
        }
        return self.container.removeLast()
    }
}

extension Stack {
    mutating func push(_ array: [T]) {
        self.container += array
    }
    
    mutating func removeAll() {
        container.removeAll()
    }
}

// Test
var stack = Stack<String>()
stack.pop()

stack.push("Autmn")
stack.push("Winter")
stack.push("Spring")
stack.push("Summer")

stack.pop()
stack.isEmpty
stack.top
stack.size

`````
-----



